/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Enhanced for professional usage
*/

import React, { useRef, useState, useEffect } from "react";
import { useGLTF } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import * as THREE from "three";
import { GLTF } from "three-stdlib";
import { ThreeEvent } from "@react-three/fiber";

// Define the type for our GLB model
type GLTFResult = GLTF & {
  nodes: Record<string, THREE.Mesh>;
  materials: Record<string, THREE.Material>;
};

// Define props interface with proper typing
interface WorkstationProps {
  autoRotate?: boolean;
  rotationSpeed?: number;
  scale?: number | [number, number, number];
  position?: [number, number, number];
  // Use React Three Fiber's JSX native types
  onClick?: (event: ThreeEvent<MouseEvent>) => void;
  onPointerOver?: (event: ThreeEvent<PointerEvent>) => void;
  onPointerOut?: (event: ThreeEvent<PointerEvent>) => void;
  [key: string]: unknown; // Allow other props to pass through with unknown type
}

export function Workstation({
  autoRotate = true,
  rotationSpeed = 0.003,
  scale = 1,
  position = [0, 0, 0],
  ...props
}: WorkstationProps) {
  const groupRef = useRef<THREE.Group>(null);
  const [hovered, setHovered] = useState(false);
  const [isDragging, setIsDragging] = useState(false);
  const [boundingBox, setBoundingBox] = useState<THREE.Box3 | null>(null);

  // Cast to unknown first, then to our expected type
  const { nodes } = useGLTF(
    "/models/workstation.glb"
  ) as unknown as GLTFResult;

  // Calculate bounding box and center the model
  useEffect(() => {
    if (groupRef.current) {
      // Create a bounding box for the model
      const box = new THREE.Box3().setFromObject(groupRef.current);
      setBoundingBox(box);

      // Calculate the center offset
      const center = new THREE.Vector3();
      box.getCenter(center);

      // Center the model by setting its position offset from its own center
      if (groupRef.current) {
        groupRef.current.position.x = position[0] - center.x;
        groupRef.current.position.y = position[1] - center.y;
        groupRef.current.position.z = position[2] - center.z;
      }
    }
  }, [position]);

  // Handle the hover state
  useEffect(() => {
    if (!isDragging) {
      document.body.style.cursor = hovered ? "pointer" : "auto";
    } else {
      document.body.style.cursor = "grabbing";
    }

    return () => {
      document.body.style.cursor = "auto";
    };
  }, [hovered, isDragging]);

  // Animation loop
  useFrame((state) => {
    if (!groupRef.current) return;

    // Only auto-rotate if enabled and not being dragged
    if (autoRotate && !isDragging) {
      groupRef.current.rotation.y += rotationSpeed;
    }

    // Subtle floating effect while maintaining centered position
    const t = state.clock.getElapsedTime();
    const floatOffset = Math.sin(t * 0.5) * 0.05;

    // Only apply floating to Y axis, preserve the centering on X and Z
    if (boundingBox) {
      const center = new THREE.Vector3();
      boundingBox.getCenter(center);
      groupRef.current.position.y = position[1] - center.y + floatOffset;
    }
  });

  // Apply the proper scale type
  const modelScale = Array.isArray(scale)
    ? scale
    : ([scale, scale, scale] as [number, number, number]);

  // Keep track of original material

  // Extract material properties for type safety
  const materialProps = {
    metalness: 0.8,
    roughness: 0.2,
    envMapIntensity: 1,
    color:
      hovered || isDragging
        ? new THREE.Color("#6366f1")
        : new THREE.Color("#a5b4fc"),
  };

  // Event handlers with proper types
  const handlePointerOver = (e: ThreeEvent<PointerEvent>) => {
    e.stopPropagation();
    setHovered(true);
  };

  const handlePointerOut = (e: ThreeEvent<PointerEvent>) => {
    e.stopPropagation();
    setHovered(false);
  };

  const handlePointerDown = (e: ThreeEvent<PointerEvent>) => {
    e.stopPropagation();
    setIsDragging(true);
  };

  const handlePointerUp = (e: ThreeEvent<PointerEvent>) => {
    e.stopPropagation();
    setIsDragging(false);
  };

  const handlePointerLeave = (e: ThreeEvent<PointerEvent>) => {
    e.stopPropagation();
    setIsDragging(false);
  };

  return (
    <group
      ref={groupRef}
      {...props}
      dispose={null}
      // Initial position before centering calculation
      position={[0, 0, 0]}
      scale={modelScale}
      onPointerOver={handlePointerOver}
      onPointerOut={handlePointerOut}
      onPointerDown={handlePointerDown}
      onPointerUp={handlePointerUp}
      onPointerLeave={handlePointerLeave}
    >
      {/* The model mesh */}
      <mesh castShadow receiveShadow geometry={nodes.mesh_0.geometry}>
        {/* Use material properties in a type-safe way */}
        <meshStandardMaterial attach="material" {...materialProps} />
      </mesh>
    </group>
  );
}

// Preload the model for better performance
useGLTF.preload("/models/workstation.glb");

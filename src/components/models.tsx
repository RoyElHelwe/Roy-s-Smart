/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Enhanced for professional usage
*/

import React, { useRef, useState, useEffect } from "react";
import { useGLTF } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import * as THREE from "three";
import { GLTF } from "three-stdlib";

// Define the type for our GLB model
type GLTFResult = GLTF & {
  nodes: Record<string, THREE.Mesh>;
  materials: Record<string, THREE.Material>;
};

// Define props interface
interface WorkstationProps {
  autoRotate?: boolean;
  rotationSpeed?: number;
  scale?: number | [number, number, number];
  position?: [number, number, number];
  [key: string]: any; // Allow other props to pass through
}

export function Workstation({
  autoRotate = true,
  rotationSpeed = 0.003,
  scale = 1,
  position = [0, 0, 0],
  ...props
}: WorkstationProps) {
  const groupRef = useRef<THREE.Group>(null);
  const [hovered, setHovered] = useState(false);
  const [isDragging, setIsDragging] = useState(false);

  // Cast to unknown first, then to our expected type
  const { nodes, materials } = useGLTF(
    "/models/workstation.glb"
  ) as unknown as GLTFResult;

  // Handle the hover state
  useEffect(() => {
    if (!isDragging) {
      document.body.style.cursor = hovered ? "pointer" : "auto";
    } else {
      document.body.style.cursor = "grabbing";
    }

    return () => {
      document.body.style.cursor = "auto";
    };
  }, [hovered, isDragging]);

  // Animation loop
  useFrame((state) => {
    if (!groupRef.current) return;

    // Only auto-rotate if enabled and not being dragged
    if (autoRotate && !isDragging) {
      groupRef.current.rotation.y += rotationSpeed;
    }

    // Subtle floating effect
    const t = state.clock.getElapsedTime();
    groupRef.current.position.y = Math.sin(t * 0.5) * 0.05 + (position[1] || 0);
  });

  // Apply the proper scale type
  const modelScale = Array.isArray(scale)
    ? scale
    : ([scale, scale, scale] as [number, number, number]);

  // Keep track of original material to reuse
  const originalMaterial = materials.material_0 || nodes.mesh_0.material;

  return (
    <group
      ref={groupRef}
      {...props}
      dispose={null}
      position={position}
      scale={modelScale}
      onPointerOver={() => setHovered(true)}
      onPointerOut={() => setHovered(false)}
      onPointerDown={() => setIsDragging(true)}
      onPointerUp={() => setIsDragging(false)}
      onPointerLeave={() => setIsDragging(false)}
    >
      {/* The model mesh */}
      <mesh castShadow receiveShadow geometry={nodes.mesh_0.geometry}>
        {/* Use cloned material to prevent original modification */}
        <meshStandardMaterial
          attach="material"
          {...originalMaterial}
          metalness={0.8}
          roughness={0.2}
          envMapIntensity={1}
          color={
            hovered || isDragging
              ? new THREE.Color("#6366f1")
              : new THREE.Color("#a5b4fc")
          }
        />
      </mesh>
    </group>
  );
}

// Preload the model for better performance
useGLTF.preload("/models/workstation.glb");
